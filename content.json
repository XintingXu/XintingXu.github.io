{"pages":[{},{}],"posts":[{"title":"一个简单的UDP测试程序","date":"2017-08-04T16:00:00.000Z","path":"2017/08/05/A-UDP-code/","text":"一个简单的UDP测试程序功能介绍这是一个简单的UDP测试程序，用于UDP数据包的发送、接收测试。 它能干什么？它集成了客户端和服务端两个部分，可以通过命令行的启动参数进行状态转换。 它可以按照一定的时间进行UDP数据包的发送，也可以设定发送的UDP数据包的负载长度，当然也可以设定每一轮发送数据包的数量。此外，服务进程监听的端口号及客户进程发送时的目标端口也是可以设定的。 不过，需要确定的是，发送时的IP地址和端口号必须是可连通的。比如，发送端和接收端的设备应该处于同一个子网中，如果发生跨子网的情况，则无法成功进行数据传送。 代码展示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330#incnclude &lt;stdio.h&gt;#include &lt;getopt.h&gt;#include &lt;stdbool.h&gt;#incle &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/time.h&gt;#include &lt;time.h&gt;char *l_opt_arg;char* const short_options = \"c:l:i:srhp:a:y:\";/*struct option&#123; const char *name; int has_arg; int *flag; int val;&#125;;*/struct option long_options[] = &#123;&#123; \"count\", 1, NULL, 'c' &#125;,&#123; \"length\", 1, NULL, 'l' &#125;,&#123; \"interval\", 1, NULL, 'i' &#125;,&#123; \"port\", 1, NULL, 'p' &#125;,&#123; \"ip\", 1, NULL, 'a' &#125;,&#123; \"cycles\", 1, NULL, 'y' &#125;,&#123; \"send\", 0, NULL, 's' &#125;,&#123; \"receive\", 0, NULL, 'r' &#125;,&#123; \"help\", 0, NULL, 'h' &#125;,&#123; 0, 0, 0, 0&#125;&#125;;void printHelp();struct ControlArguments&#123; bool isSend; bool isReceive; int SendCount; //packets to send at one time,only for send option,default 1 int PacketLength; //data length in UDP packet,only for send option,default 100 int Interval; //time between send cycles.default is 20ms,only for send option int Port; //port used for transmit int Cycles; //operation cycles,only for send option,default 10 char IP[15]; //target ip address,only for send option&#125;;void sendUDP(struct ControlArguments * const);void receiveUDP(struct ControlArguments * const);void initControlArguments(struct ControlArguments * const controlArguments)&#123; controlArguments-&gt;isSend = false; controlArguments-&gt;isReceive = false; controlArguments-&gt;SendCount = 1; controlArguments-&gt;PacketLength = 100; controlArguments-&gt;Interval = 20; controlArguments-&gt;Port = 0; controlArguments-&gt;Cycles = 10; controlArguments-&gt;IP[0] = '\\0';&#125;int charPoint2Int(char const * string)&#123; return atoi(string);&#125;int main(int argc, char *argv[])&#123; int c; int index=0; bool argumentOK = true; static struct ControlArguments controlArguments; initControlArguments(&amp;controlArguments); while((c = getopt_long (argc, argv, short_options, long_options, &amp;index)) != -1) &#123; switch (c) &#123; case 's': printf(\"Send\\n\"); controlArguments.isSend = true; break; case 'r': printf(\"Receive\\n\"); controlArguments.isReceive = true; break; case 'c': l_opt_arg = optarg; printf(\"Send Count : %s\\n\", l_opt_arg); controlArguments.SendCount = charPoint2Int(l_opt_arg); break; case 'y': l_opt_arg = optarg; printf(\"Send Cycles : %s\\n\", l_opt_arg); controlArguments.Cycles = charPoint2Int(l_opt_arg); break; case 'l': l_opt_arg = optarg; printf(\"Packet Length : %s\\n\",l_opt_arg); controlArguments.PacketLength = charPoint2Int(l_opt_arg); break; case 'i': l_opt_arg = optarg; printf(\"Interval Time : %s\\n\",l_opt_arg); controlArguments.Interval = charPoint2Int(l_opt_arg); break; case 'h': printHelp(); break; case 'p': l_opt_arg = optarg; printf(\"Chosen Port : %s\\n\",l_opt_arg); controlArguments.Port = charPoint2Int(l_opt_arg); break; case 'a': l_opt_arg = optarg; printf(\"Target IP : %s\\n\",l_opt_arg); strncpy(controlArguments.IP,l_opt_arg,15); break; default: printf(\"Do not match!!!\\n\"); argumentOK = false; &#125; &#125; if(argumentOK)&#123; if(controlArguments.isSend &amp;&amp; !controlArguments.isReceive)&#123; printf(\"choosing send\\n\"); sendUDP(&amp;controlArguments); &#125;else if(controlArguments.isReceive &amp;&amp; !controlArguments.isSend)&#123; printf(\"choosing receive\\n\"); receiveUDP(&amp;controlArguments); &#125;else&#123; printf(\"**************************\\n\"); printf(\"Arguments Error! both send and receive.\\n\"); &#125; &#125;else&#123; printf(\"************************************************\\n\"); printHelp(); &#125; return 0;&#125;void printHelp()&#123; printf(\"Help Menu:\\n Argument reference list:\\n\"); printf(\" -s :send UDP packets.\\n\"); printf(\" -r :receive UDP packets.\\n\"); printf(\" -c --count :packets to send one cycle.default is 1.\\n\"); printf(\" -y --cycles :send cycles.default is 10.\\n\"); printf(\" -l --length :data length in udp packet.default is 100bytes.\\n\"); printf(\" -i --interval :milliseconds between send options.default is 20ms.\\n\"); printf(\" -a --ip :ip address to operate.\\n\"); printf(\" -p --port :port used for UDP socket.\\n\"); printf(\" -h --help :command help.\\n\");&#125;/*Check IP Formatif format error return false;if format check passed return true;argument is the pointer to the IP string.*/bool IPFormatCheck(char * const IP)&#123; printf(\"IP check\\n\"); int ip_length = strlen(IP); bool checkError = false; int count_s = 0; for(int i = 0,interval = 0 ; i &lt; ip_length ; ++ i)&#123; if(IP[i] == '.')&#123; if(interval == 0 || interval &gt; 3)&#123; checkError = true; break; &#125;else&#123; ++ count_s; interval = 0; &#125; &#125;else if(IP[i] &gt;= '0' &amp;&amp; IP[i] &lt;= '9')&#123; ++ interval; &#125;else&#123; checkError = true; break; &#125; &#125; if(count_s != 3)&#123; checkError = true; &#125; return (!checkError);&#125;/*Check Arguments for send Processif check passed return true;if check failed return false;argument is the pointer to struct ControlArguments.*/bool checkSendConfig(struct ControlArguments * const controlArguments)&#123; printf(\"checking arguments.\\n\"); bool returnVaule; char * IP; IP = malloc(sizeof(strlen(controlArguments-&gt;IP)) + 1); strncpy(IP,controlArguments-&gt;IP,15); if(strlen(IP) != 0)&#123; if(IPFormatCheck(IP))&#123; if((controlArguments-&gt;Port == 0) || (controlArguments-&gt;PacketLength == 0))&#123; printf(\"Port:%d Length:%d\\n\",controlArguments-&gt;Port,controlArguments-&gt;PacketLength); printf(\"[Error] : Port or PacketLength Error.\\n\"); returnVaule = false; &#125;else&#123; returnVaule = true; &#125; &#125;else&#123; printf(\"[Error] : IP Error\\n\"); returnVaule = false; &#125; &#125;else&#123; printf(\"[Error] : IP length = 0!\\n\"); returnVaule = false; &#125; free(IP); return returnVaule;&#125;void threadSend(struct ControlArguments * const controlArguments)&#123; printf(\"****************************************\\nSending Thread Start\\n\"); //定义sockfd int sock_cli = socket(AF_INET,SOCK_DGRAM, 0); //定义sockaddr_in struct sockaddr_in servaddr; memset(&amp;servaddr, 0, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_port = htons(controlArguments-&gt;Port); //服务器端口 servaddr.sin_addr.s_addr = inet_addr(controlArguments-&gt;IP); //服务器ip struct timeval time; //连接服务器，成功返回0，错误返回-1 if (connect(sock_cli, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)) != 0)&#123; perror(\"connect\"); &#125;else&#123; char *sendbuf = malloc(controlArguments-&gt;PacketLength); for(int i = 0 ; i &lt; controlArguments-&gt;PacketLength - 1 ; i++)&#123; gettimeofday(&amp;time,NULL); int seed = time.tv_usec + i; sendbuf[i] = rand_r(&amp;seed) % 93 + 33; &#125; sendbuf[controlArguments-&gt;PacketLength - 1] = '\\0'; printf(\"buf : %s\\n\",sendbuf); useconds_t sleep_us = (unsigned int)controlArguments-&gt;Interval * 1000; int pack_seq = 0; for(int i = 0 ; i &lt; controlArguments-&gt;Cycles ; ++ i)&#123; for(int j = 0 ; j &lt; controlArguments-&gt;SendCount ; j++)&#123; char *realSend = malloc((strlen(sendbuf) + 20)); if(realSend)&#123; gettimeofday(&amp;time,NULL); sprintf(realSend,\"[%4ld.%06ld][%4d]:%s\",time.tv_sec,time.tv_usec,++pack_seq,sendbuf); if(send(sock_cli, realSend, strlen(realSend),0) &gt; 0)&#123; printf(\"Send Successful\\n\"); &#125; free(realSend); &#125; &#125; usleep(sleep_us); &#125; free(sendbuf);// printf(\"free.\\n\"); &#125; close(sock_cli); printf(\"Sending Thread Finish\\n****************************************\\n\");&#125;void sendUDP(struct ControlArguments * const controlArguments)&#123; if(checkSendConfig(controlArguments))&#123;// pthread_t tid; printf(\"Before Send Thread\\n\");// pthread_create(&amp;tid, NULL, threadSend(controlArguments), NULL);// pthread_tryjoin_np(tid, NULL); threadSend(controlArguments); printf(\"After Send Thread\\n\"); &#125;else&#123; ; &#125;&#125;bool checkReceiveConfig(struct ControlArguments * const controlArguments)&#123; if(controlArguments-&gt;Port == 0)&#123; printf(\"[Error] : Please set Listening port.\\n\"); return false; &#125;else&#123; return true; &#125;&#125;void threadReceive(struct ControlArguments * const controlArguments)&#123; printf(\"****************************************\\nReceiving Thread Start\\n\"); //定义sockfd int server_sockfd = socket(AF_INET,SOCK_DGRAM, 0); static int recive_serial = 0; if(server_sockfd &lt; 0)&#123; perror(\"socket\"); &#125;else&#123; //定义sockaddr_in struct sockaddr_in server_sockaddr; struct sockaddr_in client_addr; memset(&amp;server_sockaddr,0,sizeof(struct sockaddr_in)); server_sockaddr.sin_family = AF_INET; server_sockaddr.sin_port = htons(controlArguments-&gt;Port); server_sockaddr.sin_addr.s_addr = htonl(INADDR_ANY); //bind，成功返回0，出错返回-1 if(bind(server_sockfd,(struct sockaddr *)&amp;server_sockaddr,sizeof(server_sockaddr))==-1)&#123; perror(\"bind\"); &#125;else&#123; //客户端套接字 char buffer[1024]; socklen_t length = sizeof(client_addr); int recv_len = 0; struct timeval time; while(1)&#123; //成功返回非负描述字，出错返回-1 recv_len = recvfrom(server_sockfd,buffer,sizeof(buffer),0,(struct sockaddr *)&amp;client_addr,&amp;length); gettimeofday(&amp;time,NULL); if(recv_len &gt;= 0)&#123; ++ recive_serial; printf(\"[%8ld.%06ld]Get[%d][l:%d] : %s\\n\",time.tv_sec,time.tv_usec,recive_serial,recv_len,buffer); &#125; memset(&amp;buffer,0,sizeof(buffer)); &#125; &#125; &#125; close(server_sockfd); printf(\"Receiving Thread Finish\\n****************************************\\n\");&#125;void receiveUDP(struct ControlArguments * const controlArguments)&#123; if(checkReceiveConfig(controlArguments))&#123;// pthread_t tid; printf(\"Before Thread\\n\");// pthread_create(&amp;tid, NULL, threadReceive(controlArguments), NULL);// pthread_tryjoin_np(tid, NULL); threadReceive(controlArguments); printf(\"After Thread\\n\"); &#125;else&#123; ; &#125;&#125; 函数解析1.main(int argc, char *argv[])int main(int argc, char *argv[]) 主函数，用于接收参数和命令行解析。采用了getopt.h中提供的参数解析功能。可以像Linux自带的命令工具一样，可以通过短参或长参进行运行时的参数设定。 采用的参数设定方式可以调用短参数－ｈ进行查看。默认的参数设定方式如下： -s :send UDP packets. -r :receive UDP packets. -c --count :packets to send one cycle.default is 1. -y --cycles :send cycles.default is 10. -l --length :data length in udp packet.default is 100bytes. -i --interval :milliseconds between send options.default is 20ms. -a --ip :ip address to operate. -p --port :port used for UDP socket. -h --help :command help. 2．IPFormatCheck(char * const IP)bool IPFormatCheck(char * const IP) IP格式检查函数，传入的参数是输入的IP字符串，返回的是检查结果。如果IP字符串符合IP的书写格式，返回true；如果IP字符串出现错误，返回false。 该检查函数仅面向IPv4，如果输入的地址是IPv6，将返回false。 3．checkSendConfig(struct ControlArguments * const controlArguments)bool checkSendConfig(struct ControlArguments * const controlArguments) 发送参数检查，传入的参数是ControlArguments结构体指针，如果参数完备，返回true；如果参数出现冲突或者错误，返回false。 检查过程中，需要检查设定的IP地址，目标端口地址。如果任何一个参数出现错误，将返回false。 4．checkReceiveConfig(struct ControlArguments * const controlArguments)bool checkReceiveConfig(struct ControlArguments * const controlArguments) 监听参数检查，因为监听的是本地端口，所以只要本地端口号不为空即可。 传入的参数是ControlArguments结构体指针，返回值为true或者false。 5．threadSend(struct ControlArguments * const controlArguments)void threadSend(struct ControlArguments * const controlArguments) UDP数据包发送函数，可以作为单独的线程运行。传入的参数为ControlArguments结构体指针，根据设定的发送轮次和间隔、计数进行一次发送过程。 在UDP的数据负载设定中，采用了随机填充的方法，通过随机数到ASCII码的映射，实现定长负载的内容生成。 6．threadReceive(struct ControlArguments * const controlArguments)void threadReceive(struct ControlArguments * const controlArguments) socket处于轮询等待的状态，不断从缓冲区中读取数据包。在接收到数据包后，根据当前的时间添加接收时间戳，用于传输的评估。 7．sendUDP(struct ControlArguments * const controlArguments)void sendUDP(struct ControlArguments * const controlArguments) 该函数用于调用threadSend函数，在具备pthread支持的环境中，可以将发送线程作为子线程处理。因为此处不具备多线程优化的意义，所以暂时将相关功能屏蔽。 8．receiveUDP(struct ControlArguments * const controlArguments)void receiveUDP(struct ControlArguments * const controlArguments) 该函数用于调用threadReceive函数，代码中设计使用pthread进行子线程处理，因为此处多线程效果有限，相关功能暂时屏蔽。","tags":[{"name":"C","slug":"c","permalink":"http://www.xuxinting.cn/tags/c/"},{"name":"UDP","slug":"udp","permalink":"http://www.xuxinting.cn/tags/udp/"},{"name":"Linux","slug":"linux","permalink":"http://www.xuxinting.cn/tags/linux/"}]}]}